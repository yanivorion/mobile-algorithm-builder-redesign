const l=crypto,J=e=>e instanceof CryptoKey,_t=async(e,t)=>{const r=`SHA-${e.slice(-3)}`;return new Uint8Array(await l.subtle.digest(r,t))},Be=_t,E=new TextEncoder,T=new TextDecoder,re=2**32;function x(...e){const t=e.reduce((a,{length:i})=>a+i,0),r=new Uint8Array(t);let n=0;for(const a of e)r.set(a,n),n+=a.length;return r}function Ht(e,t){return x(E.encode(e),new Uint8Array([0]),t)}function we(e,t,r){if(t<0||t>=re)throw new RangeError(`value must be >= 0 and <= ${re-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,t&255],r)}function Le(e){const t=Math.floor(e/re),r=e%re,n=new Uint8Array(8);return we(n,t,0),we(n,r,4),n}function He(e){const t=new Uint8Array(4);return we(t,e),t}function fe(e){return x(He(e.length),e)}async function Kt(e,t,r){const n=Math.ceil((t>>3)/32),a=new Uint8Array(n*32);for(let i=0;i<n;i++){const s=new Uint8Array(4+e.length+r.length);s.set(He(i+1)),s.set(e,4),s.set(r,4+e.length),a.set(await Be("sha256",s),i*32)}return a.slice(0,t>>3)}const Ke=e=>{let t=e;typeof t=="string"&&(t=E.encode(t));const r=32768,n=[];for(let a=0;a<t.length;a+=r)n.push(String.fromCharCode.apply(null,t.subarray(a,a+r)));return btoa(n.join(""))},S=e=>Ke(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),Ge=e=>{const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r},m=e=>{let t=e;t instanceof Uint8Array&&(t=T.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return Ge(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class _ extends Error{constructor(t,r){var n;super(t,r),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(n=Error.captureStackTrace)==null||n.call(Error,this,this.constructor)}}_.code="ERR_JOSE_GENERIC";class v extends _{constructor(t,r,n="unspecified",a="unspecified"){super(t,{cause:{claim:n,reason:a,payload:r}}),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=n,this.reason=a,this.payload=r}}v.code="ERR_JWT_CLAIM_VALIDATION_FAILED";class ne extends _{constructor(t,r,n="unspecified",a="unspecified"){super(t,{cause:{claim:n,reason:a,payload:r}}),this.code="ERR_JWT_EXPIRED",this.claim=n,this.reason=a,this.payload=r}}ne.code="ERR_JWT_EXPIRED";class q extends _{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}}q.code="ERR_JOSE_ALG_NOT_ALLOWED";class y extends _{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}}y.code="ERR_JOSE_NOT_SUPPORTED";class z extends _{constructor(t="decryption operation failed",r){super(t,r),this.code="ERR_JWE_DECRYPTION_FAILED"}}z.code="ERR_JWE_DECRYPTION_FAILED";class u extends _{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}}u.code="ERR_JWE_INVALID";class w extends _{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}}w.code="ERR_JWS_INVALID";class W extends _{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}}W.code="ERR_JWT_INVALID";class Ce extends _{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}}Ce.code="ERR_JWK_INVALID";class ce extends _{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}}ce.code="ERR_JWKS_INVALID";class oe extends _{constructor(t="no applicable key found in the JSON Web Key Set",r){super(t,r),this.code="ERR_JWKS_NO_MATCHING_KEY"}}oe.code="ERR_JWKS_NO_MATCHING_KEY";class Pe extends _{constructor(t="multiple matching keys found in the JSON Web Key Set",r){super(t,r),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}Pe.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";class ve extends _{constructor(t="request timed out",r){super(t,r),this.code="ERR_JWKS_TIMEOUT"}}ve.code="ERR_JWKS_TIMEOUT";class de extends _{constructor(t="signature verification failed",r){super(t,r),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}de.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";const Fr=Object.freeze(Object.defineProperty({__proto__:null,JOSEAlgNotAllowed:q,JOSEError:_,JOSENotSupported:y,JWEDecryptionFailed:z,JWEInvalid:u,JWKInvalid:Ce,JWKSInvalid:ce,JWKSMultipleMatchingKeys:Pe,JWKSNoMatchingKey:oe,JWKSTimeout:ve,JWSInvalid:w,JWSSignatureVerificationFailed:de,JWTClaimValidationFailed:v,JWTExpired:ne,JWTInvalid:W},Symbol.toStringTag,{value:"Module"})),ue=l.getRandomValues.bind(l);function Fe(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new y(`Unsupported JWE Algorithm: ${e}`)}}const Ct=e=>ue(new Uint8Array(Fe(e)>>3)),Pt=(e,t)=>{if(t.length<<3!==Fe(e))throw new u("Invalid Initialization Vector length")},Ve=Pt,vt=(e,t)=>{const r=e.byteLength<<3;if(r!==t)throw new u(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)},ae=vt,Wt=(e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let n=0,a=-1;for(;++a<r;)n|=e[a]^t[a];return n===0},Jt=Wt;function b(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function R(e,t){return e.name===t}function ee(e){return parseInt(e.name.slice(4),10)}function Tt(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function ze(e,t){if(t.length&&!t.some(r=>e.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const n=t.pop();r+=`one of ${t.join(", ")}, or ${n}.`}else t.length===2?r+=`one of ${t[0]} or ${t[1]}.`:r+=`${t[0]}.`;throw new TypeError(r)}}function xt(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!R(e.algorithm,"HMAC"))throw b("HMAC");const n=parseInt(t.slice(2),10);if(ee(e.algorithm.hash)!==n)throw b(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!R(e.algorithm,"RSASSA-PKCS1-v1_5"))throw b("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(ee(e.algorithm.hash)!==n)throw b(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!R(e.algorithm,"RSA-PSS"))throw b("RSA-PSS");const n=parseInt(t.slice(2),10);if(ee(e.algorithm.hash)!==n)throw b(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":{if(e.algorithm.name!=="Ed25519"&&e.algorithm.name!=="Ed448")throw b("Ed25519 or Ed448");break}case"Ed25519":{if(!R(e.algorithm,"Ed25519"))throw b("Ed25519");break}case"ES256":case"ES384":case"ES512":{if(!R(e.algorithm,"ECDSA"))throw b("ECDSA");const n=Tt(t);if(e.algorithm.namedCurve!==n)throw b(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}ze(e,r)}function M(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!R(e.algorithm,"AES-GCM"))throw b("AES-GCM");const n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw b(n,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!R(e.algorithm,"AES-KW"))throw b("AES-KW");const n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw b(n,"algorithm.length");break}case"ECDH":{switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw b("ECDH, X25519, or X448")}break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!R(e.algorithm,"PBKDF2"))throw b("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!R(e.algorithm,"RSA-OAEP"))throw b("RSA-OAEP");const n=parseInt(t.slice(9),10)||1;if(ee(e.algorithm.hash)!==n)throw b(`SHA-${n}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}ze(e,r)}function ke(e,t,...r){var n;if(r=r.filter(Boolean),r.length>2){const a=r.pop();e+=`one of type ${r.join(", ")}, or ${a}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&(n=t.constructor)!=null&&n.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const C=(e,...t)=>ke("Key must be ",e,...t);function Xe(e,t,...r){return ke(`Key for the ${e} algorithm must be `,t,...r)}const Ye=e=>J(e)?!0:(e==null?void 0:e[Symbol.toStringTag])==="KeyObject",P=["CryptoKey"];async function Rt(e,t,r,n,a,i){if(!(t instanceof Uint8Array))throw new TypeError(C(t,"Uint8Array"));const s=parseInt(e.slice(1,4),10),c=await l.subtle.importKey("raw",t.subarray(s>>3),"AES-CBC",!1,["decrypt"]),o=await l.subtle.importKey("raw",t.subarray(0,s>>3),{hash:`SHA-${s<<1}`,name:"HMAC"},!1,["sign"]),d=x(i,n,r,Le(i.length<<3)),h=new Uint8Array((await l.subtle.sign("HMAC",o,d)).slice(0,s>>3));let f;try{f=Jt(a,h)}catch{}if(!f)throw new z;let K;try{K=new Uint8Array(await l.subtle.decrypt({iv:n,name:"AES-CBC"},c,r))}catch{}if(!K)throw new z;return K}async function It(e,t,r,n,a,i){let s;t instanceof Uint8Array?s=await l.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(M(t,e,"decrypt"),s=t);try{return new Uint8Array(await l.subtle.decrypt({additionalData:i,iv:n,name:"AES-GCM",tagLength:128},s,x(r,a)))}catch{throw new z}}const Ut=async(e,t,r,n,a,i)=>{if(!J(t)&&!(t instanceof Uint8Array))throw new TypeError(C(t,...P,"Uint8Array"));if(!n)throw new u("JWE Initialization Vector missing");if(!a)throw new u("JWE Authentication Tag missing");switch(Ve(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&ae(t,parseInt(e.slice(-3),10)),Rt(e,t,r,n,a,i);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&ae(t,parseInt(e.slice(1,4),10)),It(e,t,r,n,a,i);default:throw new y("Unsupported JWE Content Encryption Algorithm")}},qe=Ut,Ot=(...e)=>{const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const n of t){const a=Object.keys(n);if(!r||r.size===0){r=new Set(a);continue}for(const i of a){if(r.has(i))return!1;r.add(i)}}return!0},Z=Ot;function Dt(e){return typeof e=="object"&&e!==null}function g(e){if(!Dt(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}const Mt=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]],he=Mt;function Ze(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function Qe(e,t,r){if(J(e))return M(e,t,r),e;if(e instanceof Uint8Array)return l.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(C(e,...P,"Uint8Array"))}const me=async(e,t,r)=>{const n=await Qe(t,e,"wrapKey");Ze(n,e);const a=await l.subtle.importKey("raw",r,...he);return new Uint8Array(await l.subtle.wrapKey("raw",a,n,"AES-KW"))},Ee=async(e,t,r)=>{const n=await Qe(t,e,"unwrapKey");Ze(n,e);const a=await l.subtle.unwrapKey("raw",r,n,"AES-KW",...he);return new Uint8Array(await l.subtle.exportKey("raw",a))};async function je(e,t,r,n,a=new Uint8Array(0),i=new Uint8Array(0)){if(!J(e))throw new TypeError(C(e,...P));if(M(e,"ECDH"),!J(t))throw new TypeError(C(t,...P));M(t,"ECDH","deriveBits");const s=x(fe(E.encode(r)),fe(a),fe(i),He(n));let c;e.algorithm.name==="X25519"?c=256:e.algorithm.name==="X448"?c=448:c=Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;const o=new Uint8Array(await l.subtle.deriveBits({name:e.algorithm.name,public:e},t,c));return Kt(o,n,s)}async function $t(e){if(!J(e))throw new TypeError(C(e,...P));return l.subtle.generateKey(e.algorithm,!0,["deriveBits"])}function et(e){if(!J(e))throw new TypeError(C(e,...P));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||e.algorithm.name==="X25519"||e.algorithm.name==="X448"}function Nt(e){if(!(e instanceof Uint8Array)||e.length<8)throw new u("PBES2 Salt Input must be 8 or more octets")}function Bt(e,t){if(e instanceof Uint8Array)return l.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(J(e))return M(e,t,"deriveBits","deriveKey"),e;throw new TypeError(C(e,...P,"Uint8Array"))}async function tt(e,t,r,n){Nt(e);const a=Ht(t,e),i=parseInt(t.slice(13,16),10),s={hash:`SHA-${t.slice(8,11)}`,iterations:r,name:"PBKDF2",salt:a},c={length:i,name:"AES-KW"},o=await Bt(n,t);if(o.usages.includes("deriveBits"))return new Uint8Array(await l.subtle.deriveBits(s,o,i));if(o.usages.includes("deriveKey"))return l.subtle.deriveKey(s,o,c,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const Lt=async(e,t,r,n=2048,a=ue(new Uint8Array(16)))=>{const i=await tt(a,e,n,t);return{encryptedKey:await me(e.slice(-6),i,r),p2c:n,p2s:S(a)}},Gt=async(e,t,r,n,a)=>{const i=await tt(a,e,n,t);return Ee(e.slice(-6),i,r)};function ie(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new y(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}const le=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}},Ft=async(e,t,r)=>{if(!J(t))throw new TypeError(C(t,...P));if(M(t,e,"encrypt","wrapKey"),le(e,t),t.usages.includes("encrypt"))return new Uint8Array(await l.subtle.encrypt(ie(e),t,r));if(t.usages.includes("wrapKey")){const n=await l.subtle.importKey("raw",r,...he);return new Uint8Array(await l.subtle.wrapKey("raw",n,t,ie(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')},Vt=async(e,t,r)=>{if(!J(t))throw new TypeError(C(t,...P));if(M(t,e,"decrypt","unwrapKey"),le(e,t),t.usages.includes("decrypt"))return new Uint8Array(await l.subtle.decrypt(ie(e),t,r));if(t.usages.includes("unwrapKey")){const n=await l.subtle.unwrapKey("raw",r,t,ie(e),...he);return new Uint8Array(await l.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function k(e){return g(e)&&typeof e.kty=="string"}function zt(e){return e.kty!=="oct"&&typeof e.d=="string"}function kt(e){return e.kty!=="oct"&&typeof e.d>"u"}function Xt(e){return k(e)&&e.kty==="oct"&&typeof e.k=="string"}function Yt(e){let t,r;switch(e.kty){case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"Ed25519":t={name:"Ed25519"},r=e.d?["sign"]:["verify"];break;case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new y('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}const qt=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=Yt(e),n=[t,e.ext??!1,e.key_ops??r],a={...e};return delete a.alg,delete a.use,l.subtle.importKey("jwk",a,...n)},rt=qt,nt=e=>m(e);let G,F;const at=e=>(e==null?void 0:e[Symbol.toStringTag])==="KeyObject",se=async(e,t,r,n,a=!1)=>{let i=e.get(t);if(i!=null&&i[n])return i[n];const s=await rt({...r,alg:n});return a&&Object.freeze(t),i?i[n]=s:e.set(t,{[n]:s}),s},Zt=(e,t)=>{if(at(e)){let r=e.export({format:"jwk"});return delete r.d,delete r.dp,delete r.dq,delete r.p,delete r.q,delete r.qi,r.k?nt(r.k):(F||(F=new WeakMap),se(F,e,r,t))}return k(e)?e.k?m(e.k):(F||(F=new WeakMap),se(F,e,e,t,!0)):e},Qt=(e,t)=>{if(at(e)){let r=e.export({format:"jwk"});return r.k?nt(r.k):(G||(G=new WeakMap),se(G,e,r,t))}return k(e)?e.k?m(e.k):(G||(G=new WeakMap),se(G,e,e,t,!0)):e},D={normalizePublicKey:Zt,normalizePrivateKey:Qt};function We(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new y(`Unsupported JWE Algorithm: ${e}`)}}const N=e=>ue(new Uint8Array(We(e)>>3)),it=(e,t)=>{const r=(e.match(/.{1,64}/g)||[]).join(`
`);return`-----BEGIN ${t}-----
${r}
-----END ${t}-----`},st=async(e,t,r)=>{if(!J(r))throw new TypeError(C(r,...P));if(!r.extractable)throw new TypeError("CryptoKey is not extractable");if(r.type!==e)throw new TypeError(`key is not a ${e} key`);return it(Ke(new Uint8Array(await l.subtle.exportKey(t,r))),`${e.toUpperCase()} KEY`)},jt=e=>st("public","spki",e),er=e=>st("private","pkcs8",e),U=(e,t,r=0)=>{r===0&&(t.unshift(t.length),t.unshift(6));const n=e.indexOf(t[0],r);if(n===-1)return!1;const a=e.subarray(n,n+t.length);return a.length!==t.length?!1:a.every((i,s)=>i===t[s])||U(e,t,n+1)},Ue=e=>{switch(!0){case U(e,[42,134,72,206,61,3,1,7]):return"P-256";case U(e,[43,129,4,0,34]):return"P-384";case U(e,[43,129,4,0,35]):return"P-521";case U(e,[43,101,110]):return"X25519";case U(e,[43,101,111]):return"X448";case U(e,[43,101,112]):return"Ed25519";case U(e,[43,101,113]):return"Ed448";default:throw new y("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}},ct=async(e,t,r,n,a)=>{let i,s;const c=new Uint8Array(atob(r.replace(e,"")).split("").map(d=>d.charCodeAt(0))),o=t==="spki";switch(n){case"PS256":case"PS384":case"PS512":i={name:"RSA-PSS",hash:`SHA-${n.slice(-3)}`},s=o?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":i={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${n.slice(-3)}`},s=o?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":i={name:"RSA-OAEP",hash:`SHA-${parseInt(n.slice(-3),10)||1}`},s=o?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":i={name:"ECDSA",namedCurve:"P-256"},s=o?["verify"]:["sign"];break;case"ES384":i={name:"ECDSA",namedCurve:"P-384"},s=o?["verify"]:["sign"];break;case"ES512":i={name:"ECDSA",namedCurve:"P-521"},s=o?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{const d=Ue(c);i=d.startsWith("P-")?{name:"ECDH",namedCurve:d}:{name:d},s=o?[]:["deriveBits"];break}case"Ed25519":i={name:"Ed25519"},s=o?["verify"]:["sign"];break;case"EdDSA":i={name:Ue(c)},s=o?["verify"]:["sign"];break;default:throw new y('Invalid or unsupported "alg" (Algorithm) value')}return l.subtle.importKey(t,c,i,(a==null?void 0:a.extractable)??!1,s)},tr=(e,t,r)=>ct(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",e,t,r),ot=(e,t,r)=>ct(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",e,t,r);function Oe(e){const t=[];let r=0;for(;r<e.length;){const n=dt(e.subarray(r));t.push(n),r+=n.byteLength}return t}function dt(e){let t=0,r=e[0]&31;if(t++,r===31){for(r=0;e[t]>=128;)r=r*128+e[t]-128,t++;r=r*128+e[t]-128,t++}let n=0;if(e[t]<128)n=e[t],t++;else if(n===128){for(n=0;e[t+n]!==0||e[t+n+1]!==0;){if(n>e.byteLength)throw new TypeError("invalid indefinite form length");n++}const i=t+n+2;return{byteLength:i,contents:e.subarray(t,t+n),raw:e.subarray(0,i)}}else{const i=e[t]&127;t++,n=0;for(let s=0;s<i;s++)n=n*256+e[t],t++}const a=t+n;return{byteLength:a,contents:e.subarray(t,a),raw:e.subarray(0,a)}}function rr(e){const t=Oe(Oe(dt(e).contents)[0].contents);return Ke(t[t[0].raw[0]===160?6:5].raw)}function nr(e){const t=e.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,""),r=Ge(t);return it(rr(r),"PUBLIC KEY")}const ar=(e,t,r)=>{let n;try{n=nr(e)}catch(a){throw new TypeError("Failed to parse the X.509 certificate",{cause:a})}return ot(n,t,r)};async function Vr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return ot(e,t,r)}async function zr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN CERTIFICATE-----")!==0)throw new TypeError('"x509" must be X.509 formatted string');return ar(e,t,r)}async function kr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PRIVATE KEY-----")!==0)throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return tr(e,t,r)}async function pe(e,t){if(!g(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if(typeof e.k!="string"||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return m(e.k);case"RSA":if("oth"in e&&e.oth!==void 0)throw new y('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return rt({...e,alg:t});default:throw new y('Unsupported "kty" (Key Type) Parameter value')}}const V=e=>e==null?void 0:e[Symbol.toStringTag],ge=(e,t,r)=>{var n,a;if(t.use!==void 0&&t.use!=="sig")throw new TypeError("Invalid key for this operation, when present its use must be sig");if(t.key_ops!==void 0&&((a=(n=t.key_ops).includes)==null?void 0:a.call(n,r))!==!0)throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${r}`);if(t.alg!==void 0&&t.alg!==e)throw new TypeError(`Invalid key for this operation, when present its alg must be ${e}`);return!0},ir=(e,t,r,n)=>{if(!(t instanceof Uint8Array)){if(n&&k(t)){if(Xt(t)&&ge(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!Ye(t))throw new TypeError(Xe(e,t,...P,"Uint8Array",n?"JSON Web Key":null));if(t.type!=="secret")throw new TypeError(`${V(t)} instances for symmetric algorithms must be of type "secret"`)}},sr=(e,t,r,n)=>{if(n&&k(t))switch(r){case"sign":if(zt(t)&&ge(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"verify":if(kt(t)&&ge(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!Ye(t))throw new TypeError(Xe(e,t,...P,n?"JSON Web Key":null));if(t.type==="secret")throw new TypeError(`${V(t)} instances for asymmetric algorithms must not be of type "secret"`);if(r==="sign"&&t.type==="public")throw new TypeError(`${V(t)} instances for asymmetric algorithm signing must be of type "private"`);if(r==="decrypt"&&t.type==="public")throw new TypeError(`${V(t)} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&r==="verify"&&t.type==="private")throw new TypeError(`${V(t)} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&r==="encrypt"&&t.type==="private")throw new TypeError(`${V(t)} instances for asymmetric algorithm encryption must be of type "public"`)};function ut(e,t,r,n){t.startsWith("HS")||t==="dir"||t.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(t)?ir(t,r,n,e):sr(t,r,n,e)}const ht=ut.bind(void 0,!1),Se=ut.bind(void 0,!0);async function cr(e,t,r,n,a){if(!(r instanceof Uint8Array))throw new TypeError(C(r,"Uint8Array"));const i=parseInt(e.slice(1,4),10),s=await l.subtle.importKey("raw",r.subarray(i>>3),"AES-CBC",!1,["encrypt"]),c=await l.subtle.importKey("raw",r.subarray(0,i>>3),{hash:`SHA-${i<<1}`,name:"HMAC"},!1,["sign"]),o=new Uint8Array(await l.subtle.encrypt({iv:n,name:"AES-CBC"},s,t)),d=x(a,n,o,Le(a.length<<3)),h=new Uint8Array((await l.subtle.sign("HMAC",c,d)).slice(0,i>>3));return{ciphertext:o,tag:h,iv:n}}async function or(e,t,r,n,a){let i;r instanceof Uint8Array?i=await l.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(M(r,e,"encrypt"),i=r);const s=new Uint8Array(await l.subtle.encrypt({additionalData:a,iv:n,name:"AES-GCM",tagLength:128},i,t)),c=s.slice(-16);return{ciphertext:s.slice(0,-16),tag:c,iv:n}}const dr=async(e,t,r,n,a)=>{if(!J(r)&&!(r instanceof Uint8Array))throw new TypeError(C(r,...P,"Uint8Array"));switch(n?Ve(e,n):n=Ct(e),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r instanceof Uint8Array&&ae(r,parseInt(e.slice(-3),10)),cr(e,t,r,n,a);case"A128GCM":case"A192GCM":case"A256GCM":return r instanceof Uint8Array&&ae(r,parseInt(e.slice(1,4),10)),or(e,t,r,n,a);default:throw new y("Unsupported JWE Content Encryption Algorithm")}},lt=dr;async function ur(e,t,r,n){const a=e.slice(0,7),i=await lt(a,r,t,n,new Uint8Array(0));return{encryptedKey:i.ciphertext,iv:S(i.iv),tag:S(i.tag)}}async function hr(e,t,r,n,a){const i=e.slice(0,7);return qe(i,t,r,n,a,new Uint8Array(0))}async function lr(e,t,r,n,a){var i;switch(ht(e,t,"decrypt"),t=await((i=D.normalizePrivateKey)==null?void 0:i.call(D,t,e))||t,e){case"dir":{if(r!==void 0)throw new u("Encountered unexpected JWE Encrypted Key");return t}case"ECDH-ES":if(r!==void 0)throw new u("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!g(n.epk))throw new u('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!et(t))throw new y("ECDH with the provided key is not allowed or not supported by your javascript runtime");const s=await pe(n.epk,e);let c,o;if(n.apu!==void 0){if(typeof n.apu!="string")throw new u('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{c=m(n.apu)}catch{throw new u("Failed to base64url decode the apu")}}if(n.apv!==void 0){if(typeof n.apv!="string")throw new u('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{o=m(n.apv)}catch{throw new u("Failed to base64url decode the apv")}}const d=await je(s,t,e==="ECDH-ES"?n.enc:e,e==="ECDH-ES"?We(n.enc):parseInt(e.slice(-5,-2),10),c,o);if(e==="ECDH-ES")return d;if(r===void 0)throw new u("JWE Encrypted Key missing");return Ee(e.slice(-6),d,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(r===void 0)throw new u("JWE Encrypted Key missing");return Vt(e,t,r)}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(r===void 0)throw new u("JWE Encrypted Key missing");if(typeof n.p2c!="number")throw new u('JOSE Header "p2c" (PBES2 Count) missing or invalid');const s=(a==null?void 0:a.maxPBES2Count)||1e4;if(n.p2c>s)throw new u('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if(typeof n.p2s!="string")throw new u('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let c;try{c=m(n.p2s)}catch{throw new u("Failed to base64url decode the p2s")}return Gt(e,t,r,n.p2c,c)}case"A128KW":case"A192KW":case"A256KW":{if(r===void 0)throw new u("JWE Encrypted Key missing");return Ee(e,t,r)}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(r===void 0)throw new u("JWE Encrypted Key missing");if(typeof n.iv!="string")throw new u('JOSE Header "iv" (Initialization Vector) missing or invalid');if(typeof n.tag!="string")throw new u('JOSE Header "tag" (Authentication Tag) missing or invalid');let s;try{s=m(n.iv)}catch{throw new u("Failed to base64url decode the iv")}let c;try{c=m(n.tag)}catch{throw new u("Failed to base64url decode the tag")}return hr(e,t,r,s,c)}default:throw new y('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function Q(e,t,r,n,a){if(a.crit!==void 0&&(n==null?void 0:n.crit)===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(s=>typeof s!="string"||s.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;r!==void 0?i=new Map([...Object.entries(r),...t.entries()]):i=t;for(const s of n.crit){if(!i.has(s))throw new y(`Extension Header Parameter "${s}" is not recognized`);if(a[s]===void 0)throw new e(`Extension Header Parameter "${s}" is missing`);if(i.get(s)&&n[s]===void 0)throw new e(`Extension Header Parameter "${s}" MUST be integrity protected`)}return new Set(n.crit)}const pr=(e,t)=>{if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)},Ae=pr;async function pt(e,t,r){if(!g(e))throw new u("Flattened JWE must be an object");if(e.protected===void 0&&e.header===void 0&&e.unprotected===void 0)throw new u("JOSE Header missing");if(e.iv!==void 0&&typeof e.iv!="string")throw new u("JWE Initialization Vector incorrect type");if(typeof e.ciphertext!="string")throw new u("JWE Ciphertext missing or incorrect type");if(e.tag!==void 0&&typeof e.tag!="string")throw new u("JWE Authentication Tag incorrect type");if(e.protected!==void 0&&typeof e.protected!="string")throw new u("JWE Protected Header incorrect type");if(e.encrypted_key!==void 0&&typeof e.encrypted_key!="string")throw new u("JWE Encrypted Key incorrect type");if(e.aad!==void 0&&typeof e.aad!="string")throw new u("JWE AAD incorrect type");if(e.header!==void 0&&!g(e.header))throw new u("JWE Shared Unprotected Header incorrect type");if(e.unprotected!==void 0&&!g(e.unprotected))throw new u("JWE Per-Recipient Unprotected Header incorrect type");let n;if(e.protected)try{const L=m(e.protected);n=JSON.parse(T.decode(L))}catch{throw new u("JWE Protected Header is invalid")}if(!Z(n,e.header,e.unprotected))throw new u("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const a={...n,...e.header,...e.unprotected};if(Q(u,new Map,r==null?void 0:r.crit,n,a),a.zip!==void 0)throw new y('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:i,enc:s}=a;if(typeof i!="string"||!i)throw new u("missing JWE Algorithm (alg) in JWE Header");if(typeof s!="string"||!s)throw new u("missing JWE Encryption Algorithm (enc) in JWE Header");const c=r&&Ae("keyManagementAlgorithms",r.keyManagementAlgorithms),o=r&&Ae("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(c&&!c.has(i)||!c&&i.startsWith("PBES2"))throw new q('"alg" (Algorithm) Header Parameter value not allowed');if(o&&!o.has(s))throw new q('"enc" (Encryption Algorithm) Header Parameter value not allowed');let d;if(e.encrypted_key!==void 0)try{d=m(e.encrypted_key)}catch{throw new u("Failed to base64url decode the encrypted_key")}let h=!1;typeof t=="function"&&(t=await t(n,e),h=!0);let f;try{f=await lr(i,t,d,a,r)}catch(L){if(L instanceof TypeError||L instanceof u||L instanceof y)throw L;f=N(s)}let K,A;if(e.iv!==void 0)try{K=m(e.iv)}catch{throw new u("Failed to base64url decode the iv")}if(e.tag!==void 0)try{A=m(e.tag)}catch{throw new u("Failed to base64url decode the tag")}const p=E.encode(e.protected??"");let H;e.aad!==void 0?H=x(p,E.encode("."),E.encode(e.aad)):H=p;let X;try{X=m(e.ciphertext)}catch{throw new u("Failed to base64url decode the ciphertext")}const B={plaintext:await qe(s,f,X,K,A,H)};if(e.protected!==void 0&&(B.protectedHeader=n),e.aad!==void 0)try{B.additionalAuthenticatedData=m(e.aad)}catch{throw new u("Failed to base64url decode the aad")}return e.unprotected!==void 0&&(B.sharedUnprotectedHeader=e.unprotected),e.header!==void 0&&(B.unprotectedHeader=e.header),h?{...B,key:t}:B}async function fr(e,t,r){if(e instanceof Uint8Array&&(e=T.decode(e)),typeof e!="string")throw new u("Compact JWE must be a string or Uint8Array");const{0:n,1:a,2:i,3:s,4:c,length:o}=e.split(".");if(o!==5)throw new u("Invalid Compact JWE");const d=await pt({ciphertext:s,iv:i||void 0,protected:n,tag:c||void 0,encrypted_key:a||void 0},t,r),h={plaintext:d.plaintext,protectedHeader:d.protectedHeader};return typeof t=="function"?{...h,key:d.key}:h}async function Xr(e,t,r){if(!g(e))throw new u("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(g))throw new u("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new u("JWE Recipients has no members");for(const n of e.recipients)try{return await pt({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:n.encrypted_key,header:n.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch{}throw new z}const ft=Symbol(),yr=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:S(e)};if(!J(e))throw new TypeError(C(e,...P,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:r,alg:n,use:a,...i}=await l.subtle.exportKey("jwk",e);return i},wr=yr;async function Yr(e){return jt(e)}async function qr(e){return er(e)}async function mr(e){return wr(e)}async function yt(e,t,r,n,a={}){var o;let i,s,c;switch(ht(e,r,"encrypt"),r=await((o=D.normalizePublicKey)==null?void 0:o.call(D,r,e))||r,e){case"dir":{c=r;break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!et(r))throw new y("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:d,apv:h}=a;let{epk:f}=a;f||(f=(await $t(r)).privateKey);const{x:K,y:A,crv:p,kty:H}=await mr(f),X=await je(r,f,e==="ECDH-ES"?t:e,e==="ECDH-ES"?We(t):parseInt(e.slice(-5,-2),10),d,h);if(s={epk:{x:K,crv:p,kty:H}},H==="EC"&&(s.epk.y=A),d&&(s.apu=S(d)),h&&(s.apv=S(h)),e==="ECDH-ES"){c=X;break}c=n||N(t);const Ie=e.slice(-6);i=await me(Ie,X,c);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{c=n||N(t),i=await Ft(e,r,c);break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{c=n||N(t);const{p2c:d,p2s:h}=a;({encryptedKey:i,...s}=await Lt(e,r,c,d,h));break}case"A128KW":case"A192KW":case"A256KW":{c=n||N(t),i=await me(e,r,c);break}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{c=n||N(t);const{iv:d}=a;({encryptedKey:i,...s}=await ur(e,r,c,d));break}default:throw new y('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:c,encryptedKey:i,parameters:s}}class be{constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=t}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}async encrypt(t,r){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new u("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!Z(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new u("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const n={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(Q(u,new Map,r==null?void 0:r.crit,this._protectedHeader,n),n.zip!==void 0)throw new y('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:a,enc:i}=n;if(typeof a!="string"||!a)throw new u('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(typeof i!="string"||!i)throw new u('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let s;if(this._cek&&(a==="dir"||a==="ECDH-ES"))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${a}`);let c;{let H;({cek:c,encryptedKey:s,parameters:H}=await yt(a,i,t,this._cek,this._keyManagementParameters)),H&&(r&&ft in r?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...H}:this.setUnprotectedHeader(H):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...H}:this.setProtectedHeader(H))}let o,d,h;this._protectedHeader?d=E.encode(S(JSON.stringify(this._protectedHeader))):d=E.encode(""),this._aad?(h=S(this._aad),o=x(d,E.encode("."),E.encode(h))):o=d;const{ciphertext:f,tag:K,iv:A}=await lt(i,this._plaintext,c,this._iv,o),p={ciphertext:S(f)};return A&&(p.iv=S(A)),K&&(p.tag=S(K)),s&&(p.encrypted_key=S(s)),h&&(p.aad=h),this._protectedHeader&&(p.protected=T.decode(d)),this._sharedUnprotectedHeader&&(p.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(p.header=this._unprotectedHeader),p}}class Er{constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addRecipient(...t){return this.parent.addRecipient(...t)}encrypt(...t){return this.parent.encrypt(...t)}done(){return this.parent}}class Zr{constructor(t){this._recipients=[],this._plaintext=t}addRecipient(t,r){const n=new Er(this,t,{crit:r==null?void 0:r.crit});return this._recipients.push(n),n}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}async encrypt(){var a,i,s;if(!this._recipients.length)throw new u("at least one recipient must be added");if(this._recipients.length===1){const[c]=this._recipients,o=await new be(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(c.unprotectedHeader).encrypt(c.key,{...c.options}),d={ciphertext:o.ciphertext,iv:o.iv,recipients:[{}],tag:o.tag};return o.aad&&(d.aad=o.aad),o.protected&&(d.protected=o.protected),o.unprotected&&(d.unprotected=o.unprotected),o.encrypted_key&&(d.recipients[0].encrypted_key=o.encrypted_key),o.header&&(d.recipients[0].header=o.header),d}let t;for(let c=0;c<this._recipients.length;c++){const o=this._recipients[c];if(!Z(this._protectedHeader,this._unprotectedHeader,o.unprotectedHeader))throw new u("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const d={...this._protectedHeader,...this._unprotectedHeader,...o.unprotectedHeader},{alg:h}=d;if(typeof h!="string"||!h)throw new u('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(h==="dir"||h==="ECDH-ES")throw new u('"dir" and "ECDH-ES" alg may only be used with a single recipient');if(typeof d.enc!="string"||!d.enc)throw new u('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(!t)t=d.enc;else if(t!==d.enc)throw new u('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');if(Q(u,new Map,o.options.crit,this._protectedHeader,d),d.zip!==void 0)throw new y('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const r=N(t),n={ciphertext:"",iv:"",recipients:[],tag:""};for(let c=0;c<this._recipients.length;c++){const o=this._recipients[c],d={};n.recipients.push(d);const f={...this._protectedHeader,...this._unprotectedHeader,...o.unprotectedHeader}.alg.startsWith("PBES2")?2048+c:void 0;if(c===0){const p=await new be(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(r).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(o.unprotectedHeader).setKeyManagementParameters({p2c:f}).encrypt(o.key,{...o.options,[ft]:!0});n.ciphertext=p.ciphertext,n.iv=p.iv,n.tag=p.tag,p.aad&&(n.aad=p.aad),p.protected&&(n.protected=p.protected),p.unprotected&&(n.unprotected=p.unprotected),d.encrypted_key=p.encrypted_key,p.header&&(d.header=p.header);continue}const{encryptedKey:K,parameters:A}=await yt(((a=o.unprotectedHeader)==null?void 0:a.alg)||((i=this._protectedHeader)==null?void 0:i.alg)||((s=this._unprotectedHeader)==null?void 0:s.alg),t,o.key,r,{p2c:f});d.encrypted_key=S(K),(o.unprotectedHeader||A)&&(d.header={...o.unprotectedHeader,...A})}return n}}function wt(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"Ed25519":return{name:"Ed25519"};case"EdDSA":return{name:t.name};default:throw new y(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}async function mt(e,t,r){if(r==="sign"&&(t=await D.normalizePrivateKey(t,e)),r==="verify"&&(t=await D.normalizePublicKey(t,e)),J(t))return xt(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(C(t,...P));return l.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(C(t,...P,"Uint8Array","JSON Web Key"))}const gr=async(e,t,r,n)=>{const a=await mt(e,t,"verify");le(e,a);const i=wt(e,a.algorithm);try{return await l.subtle.verify(i,a,r,n)}catch{return!1}},Sr=gr;async function Et(e,t,r){if(!g(e))throw new w("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new w('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new w("JWS Protected Header incorrect type");if(e.payload===void 0)throw new w("JWS Payload missing");if(typeof e.signature!="string")throw new w("JWS Signature missing or incorrect type");if(e.header!==void 0&&!g(e.header))throw new w("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const H=m(e.protected);n=JSON.parse(T.decode(H))}catch{throw new w("JWS Protected Header is invalid")}if(!Z(n,e.header))throw new w("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...n,...e.header},i=Q(w,new Map([["b64",!0]]),r==null?void 0:r.crit,n,a);let s=!0;if(i.has("b64")&&(s=n.b64,typeof s!="boolean"))throw new w('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=a;if(typeof c!="string"||!c)throw new w('JWS "alg" (Algorithm) Header Parameter missing or invalid');const o=r&&Ae("algorithms",r.algorithms);if(o&&!o.has(c))throw new q('"alg" (Algorithm) Header Parameter value not allowed');if(s){if(typeof e.payload!="string")throw new w("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new w("JWS Payload must be a string or an Uint8Array instance");let d=!1;typeof t=="function"?(t=await t(n,e),d=!0,Se(c,t,"verify"),k(t)&&(t=await pe(t,c))):Se(c,t,"verify");const h=x(E.encode(e.protected??""),E.encode("."),typeof e.payload=="string"?E.encode(e.payload):e.payload);let f;try{f=m(e.signature)}catch{throw new w("Failed to base64url decode the signature")}if(!await Sr(c,t,f,h))throw new de;let A;if(s)try{A=m(e.payload)}catch{throw new w("Failed to base64url decode the payload")}else typeof e.payload=="string"?A=E.encode(e.payload):A=e.payload;const p={payload:A};return e.protected!==void 0&&(p.protectedHeader=n),e.header!==void 0&&(p.unprotectedHeader=e.header),d?{...p,key:t}:p}async function Ar(e,t,r){if(e instanceof Uint8Array&&(e=T.decode(e)),typeof e!="string")throw new w("Compact JWS must be a string or Uint8Array");const{0:n,1:a,2:i,length:s}=e.split(".");if(s!==3)throw new w("Invalid Compact JWS");const c=await Et({payload:a,protected:n,signature:i},t,r),o={payload:c.payload,protectedHeader:c.protectedHeader};return typeof t=="function"?{...o,key:c.key}:o}async function Qr(e,t,r){if(!g(e))throw new w("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(g))throw new w("JWS Signatures missing or incorrect type");for(const n of e.signatures)try{return await Et({header:n.header,payload:e.payload,protected:n.protected,signature:n.signature},t,r)}catch{}throw new de}const O=e=>Math.floor(e.getTime()/1e3),gt=60,St=gt*60,Je=St*24,br=Je*7,_r=Je*365.25,Hr=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,Y=e=>{const t=Hr.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]),n=t[3].toLowerCase();let a;switch(n){case"sec":case"secs":case"second":case"seconds":case"s":a=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":a=Math.round(r*gt);break;case"hour":case"hours":case"hr":case"hrs":case"h":a=Math.round(r*St);break;case"day":case"days":case"d":a=Math.round(r*Je);break;case"week":case"weeks":case"w":a=Math.round(r*br);break;default:a=Math.round(r*_r);break}return t[1]==="-"||t[4]==="ago"?-a:a},De=e=>e.toLowerCase().replace(/^application\//,""),Kr=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1,Te=(e,t,r={})=>{let n;try{n=JSON.parse(T.decode(t))}catch{}if(!g(n))throw new W("JWT Claims Set must be a top-level JSON object");const{typ:a}=r;if(a&&(typeof e.typ!="string"||De(e.typ)!==De(a)))throw new v('unexpected "typ" JWT header value',n,"typ","check_failed");const{requiredClaims:i=[],issuer:s,subject:c,audience:o,maxTokenAge:d}=r,h=[...i];d!==void 0&&h.push("iat"),o!==void 0&&h.push("aud"),c!==void 0&&h.push("sub"),s!==void 0&&h.push("iss");for(const p of new Set(h.reverse()))if(!(p in n))throw new v(`missing required "${p}" claim`,n,p,"missing");if(s&&!(Array.isArray(s)?s:[s]).includes(n.iss))throw new v('unexpected "iss" claim value',n,"iss","check_failed");if(c&&n.sub!==c)throw new v('unexpected "sub" claim value',n,"sub","check_failed");if(o&&!Kr(n.aud,typeof o=="string"?[o]:o))throw new v('unexpected "aud" claim value',n,"aud","check_failed");let f;switch(typeof r.clockTolerance){case"string":f=Y(r.clockTolerance);break;case"number":f=r.clockTolerance;break;case"undefined":f=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:K}=r,A=O(K||new Date);if((n.iat!==void 0||d)&&typeof n.iat!="number")throw new v('"iat" claim must be a number',n,"iat","invalid");if(n.nbf!==void 0){if(typeof n.nbf!="number")throw new v('"nbf" claim must be a number',n,"nbf","invalid");if(n.nbf>A+f)throw new v('"nbf" claim timestamp check failed',n,"nbf","check_failed")}if(n.exp!==void 0){if(typeof n.exp!="number")throw new v('"exp" claim must be a number',n,"exp","invalid");if(n.exp<=A-f)throw new ne('"exp" claim timestamp check failed',n,"exp","check_failed")}if(d){const p=A-n.iat,H=typeof d=="number"?d:Y(d);if(p-f>H)throw new ne('"iat" claim timestamp check failed (too far in the past)',n,"iat","check_failed");if(p<0-f)throw new v('"iat" claim timestamp check failed (it should be in the past)',n,"iat","check_failed")}return n};async function jr(e,t,r){var s;const n=await Ar(e,t,r);if((s=n.protectedHeader.crit)!=null&&s.includes("b64")&&n.protectedHeader.b64===!1)throw new W("JWTs MUST NOT use unencoded payload");const i={payload:Te(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof t=="function"?{...i,key:n.key}:i}async function en(e,t,r){const n=await fr(e,t,r),a=Te(n.protectedHeader,n.plaintext,r),{protectedHeader:i}=n;if(i.iss!==void 0&&i.iss!==a.iss)throw new v('replicated "iss" claim header parameter mismatch',a,"iss","mismatch");if(i.sub!==void 0&&i.sub!==a.sub)throw new v('replicated "sub" claim header parameter mismatch',a,"sub","mismatch");if(i.aud!==void 0&&JSON.stringify(i.aud)!==JSON.stringify(a.aud))throw new v('replicated "aud" claim header parameter mismatch',a,"aud","mismatch");const s={payload:a,protectedHeader:i};return typeof t=="function"?{...s,key:n.key}:s}class Cr{constructor(t){this._flattened=new be(t)}setContentEncryptionKey(t){return this._flattened.setContentEncryptionKey(t),this}setInitializationVector(t){return this._flattened.setInitializationVector(t),this}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}setKeyManagementParameters(t){return this._flattened.setKeyManagementParameters(t),this}async encrypt(t,r){const n=await this._flattened.encrypt(t,r);return[n.protected,n.encrypted_key,n.iv,n.ciphertext,n.tag].join(".")}}const Pr=async(e,t,r)=>{const n=await mt(e,t,"sign");le(e,n);const a=await l.subtle.sign(wt(e,n.algorithm),n,r);return new Uint8Array(a)},vr=Pr;class At{constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=t}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}async sign(t,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new w("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!Z(this._protectedHeader,this._unprotectedHeader))throw new w("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const n={...this._protectedHeader,...this._unprotectedHeader},a=Q(w,new Map([["b64",!0]]),r==null?void 0:r.crit,this._protectedHeader,n);let i=!0;if(a.has("b64")&&(i=this._protectedHeader.b64,typeof i!="boolean"))throw new w('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=n;if(typeof s!="string"||!s)throw new w('JWS "alg" (Algorithm) Header Parameter missing or invalid');Se(s,t,"sign");let c=this._payload;i&&(c=E.encode(S(c)));let o;this._protectedHeader?o=E.encode(S(JSON.stringify(this._protectedHeader))):o=E.encode("");const d=x(o,E.encode("."),c),h=await vr(s,t,d),f={signature:S(h),payload:""};return i&&(f.payload=T.decode(c)),this._unprotectedHeader&&(f.header=this._unprotectedHeader),this._protectedHeader&&(f.protected=T.decode(o)),f}}class Wr{constructor(t){this._flattened=new At(t)}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}async sign(t,r){const n=await this._flattened.sign(t,r);if(n.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${n.protected}.${n.payload}.${n.signature}`}}class Jr{constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setProtectedHeader(t){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=t,this}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addSignature(...t){return this.parent.addSignature(...t)}sign(...t){return this.parent.sign(...t)}done(){return this.parent}}class tn{constructor(t){this._signatures=[],this._payload=t}addSignature(t,r){const n=new Jr(this,t,r);return this._signatures.push(n),n}async sign(){if(!this._signatures.length)throw new w("at least one signature must be added");const t={signatures:[],payload:""};for(let r=0;r<this._signatures.length;r++){const n=this._signatures[r],a=new At(this._payload);a.setProtectedHeader(n.protectedHeader),a.setUnprotectedHeader(n.unprotectedHeader);const{payload:i,...s}=await a.sign(n.key,n.options);if(r===0)t.payload=i;else if(t.payload!==i)throw new w("inconsistent use of JWS Unencoded Payload (RFC7797)");t.signatures.push(s)}return t}}function $(e,t){if(!Number.isFinite(t))throw new TypeError(`Invalid ${e} input`);return t}class xe{constructor(t={}){if(!g(t))throw new TypeError("JWT Claims Set MUST be an object");this._payload=t}setIssuer(t){return this._payload={...this._payload,iss:t},this}setSubject(t){return this._payload={...this._payload,sub:t},this}setAudience(t){return this._payload={...this._payload,aud:t},this}setJti(t){return this._payload={...this._payload,jti:t},this}setNotBefore(t){return typeof t=="number"?this._payload={...this._payload,nbf:$("setNotBefore",t)}:t instanceof Date?this._payload={...this._payload,nbf:$("setNotBefore",O(t))}:this._payload={...this._payload,nbf:O(new Date)+Y(t)},this}setExpirationTime(t){return typeof t=="number"?this._payload={...this._payload,exp:$("setExpirationTime",t)}:t instanceof Date?this._payload={...this._payload,exp:$("setExpirationTime",O(t))}:this._payload={...this._payload,exp:O(new Date)+Y(t)},this}setIssuedAt(t){return typeof t>"u"?this._payload={...this._payload,iat:O(new Date)}:t instanceof Date?this._payload={...this._payload,iat:$("setIssuedAt",O(t))}:typeof t=="string"?this._payload={...this._payload,iat:$("setIssuedAt",O(new Date)+Y(t))}:this._payload={...this._payload,iat:$("setIssuedAt",t)},this}}class rn extends xe{setProtectedHeader(t){return this._protectedHeader=t,this}async sign(t,r){var a;const n=new Wr(E.encode(JSON.stringify(this._payload)));if(n.setProtectedHeader(this._protectedHeader),Array.isArray((a=this._protectedHeader)==null?void 0:a.crit)&&this._protectedHeader.crit.includes("b64")&&this._protectedHeader.b64===!1)throw new W("JWTs MUST NOT use unencoded payload");return n.sign(t,r)}}class nn extends xe{setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}replicateIssuerAsHeader(){return this._replicateIssuerAsHeader=!0,this}replicateSubjectAsHeader(){return this._replicateSubjectAsHeader=!0,this}replicateAudienceAsHeader(){return this._replicateAudienceAsHeader=!0,this}async encrypt(t,r){const n=new Cr(E.encode(JSON.stringify(this._payload)));return this._replicateIssuerAsHeader&&(this._protectedHeader={...this._protectedHeader,iss:this._payload.iss}),this._replicateSubjectAsHeader&&(this._protectedHeader={...this._protectedHeader,sub:this._payload.sub}),this._replicateAudienceAsHeader&&(this._protectedHeader={...this._protectedHeader,aud:this._payload.aud}),n.setProtectedHeader(this._protectedHeader),this._iv&&n.setInitializationVector(this._iv),this._cek&&n.setContentEncryptionKey(this._cek),this._keyManagementParameters&&n.setKeyManagementParameters(this._keyManagementParameters),n.encrypt(t,r)}}const I=(e,t)=>{if(typeof e!="string"||!e)throw new Ce(`${t} missing or invalid`)};async function Tr(e,t){if(!g(e))throw new TypeError("JWK must be an object");if(t??(t="sha256"),t!=="sha256"&&t!=="sha384"&&t!=="sha512")throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let r;switch(e.kty){case"EC":I(e.crv,'"crv" (Curve) Parameter'),I(e.x,'"x" (X Coordinate) Parameter'),I(e.y,'"y" (Y Coordinate) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":I(e.crv,'"crv" (Subtype of Key Pair) Parameter'),I(e.x,'"x" (Public Key) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":I(e.e,'"e" (Exponent) Parameter'),I(e.n,'"n" (Modulus) Parameter'),r={e:e.e,kty:e.kty,n:e.n};break;case"oct":I(e.k,'"k" (Key Value) Parameter'),r={k:e.k,kty:e.kty};break;default:throw new y('"kty" (Key Type) Parameter missing or unsupported')}const n=E.encode(JSON.stringify(r));return S(await Be(t,n))}async function an(e,t){t??(t="sha256");const r=await Tr(e,t);return`urn:ietf:params:oauth:jwk-thumbprint:sha-${t.slice(-3)}:${r}`}async function sn(e,t){const r={...e,...t==null?void 0:t.header};if(!g(r.jwk))throw new w('"jwk" (JSON Web Key) Header Parameter must be a JSON object');const n=await pe({...r.jwk,ext:!0},r.alg);if(n instanceof Uint8Array||n.type!=="public")throw new w('"jwk" (JSON Web Key) Header Parameter must be a public key');return n}function xr(e){switch(typeof e=="string"&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new y('Unsupported "alg" value for a JSON Web Key Set')}}function Rr(e){return e&&typeof e=="object"&&Array.isArray(e.keys)&&e.keys.every(Ir)}function Ir(e){return g(e)}function bt(e){return typeof structuredClone=="function"?structuredClone(e):JSON.parse(JSON.stringify(e))}class Ur{constructor(t){if(this._cached=new WeakMap,!Rr(t))throw new ce("JSON Web Key Set malformed");this._jwks=bt(t)}async getKey(t,r){const{alg:n,kid:a}={...t,...r==null?void 0:r.header},i=xr(n),s=this._jwks.keys.filter(d=>{let h=i===d.kty;if(h&&typeof a=="string"&&(h=a===d.kid),h&&typeof d.alg=="string"&&(h=n===d.alg),h&&typeof d.use=="string"&&(h=d.use==="sig"),h&&Array.isArray(d.key_ops)&&(h=d.key_ops.includes("verify")),h)switch(n){case"ES256":h=d.crv==="P-256";break;case"ES256K":h=d.crv==="secp256k1";break;case"ES384":h=d.crv==="P-384";break;case"ES512":h=d.crv==="P-521";break;case"Ed25519":h=d.crv==="Ed25519";break;case"EdDSA":h=d.crv==="Ed25519"||d.crv==="Ed448";break}return h}),{0:c,length:o}=s;if(o===0)throw new oe;if(o!==1){const d=new Pe,{_cached:h}=this;throw d[Symbol.asyncIterator]=async function*(){for(const f of s)try{yield await Me(h,f,n)}catch{}},d}return Me(this._cached,c,n)}}async function Me(e,t,r){const n=e.get(t)||e.set(t,{}).get(t);if(n[r]===void 0){const a=await pe({...t,ext:!0},r);if(a instanceof Uint8Array||a.type!=="public")throw new ce("JSON Web Key Set members must be public keys");n[r]=a}return n[r]}function $e(e){const t=new Ur(e),r=async(n,a)=>t.getKey(n,a);return Object.defineProperties(r,{jwks:{value:()=>bt(t._jwks),enumerable:!0,configurable:!1,writable:!1}}),r}const Or=async(e,t,r)=>{let n,a,i=!1;typeof AbortController=="function"&&(n=new AbortController,a=setTimeout(()=>{i=!0,n.abort()},t));const s=await fetch(e.href,{signal:n?n.signal:void 0,redirect:"manual",headers:r.headers}).catch(c=>{throw i?new ve:c});if(a!==void 0&&clearTimeout(a),s.status!==200)throw new _("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await s.json()}catch{throw new _("Failed to parse the JSON Web Key Set HTTP response as JSON")}},Dr=Or;function Mr(){return typeof WebSocketPair<"u"||typeof navigator<"u"&&navigator.userAgent==="Cloudflare-Workers"||typeof EdgeRuntime<"u"&&EdgeRuntime==="vercel"}let _e;var j,Ne;(typeof navigator>"u"||!((Ne=(j=navigator.userAgent)==null?void 0:j.startsWith)!=null&&Ne.call(j,"Mozilla/5.0 ")))&&(_e="jose/v5.10.0");const te=Symbol();function $r(e,t){return!(typeof e!="object"||e===null||!("uat"in e)||typeof e.uat!="number"||Date.now()-e.uat>=t||!("jwks"in e)||!g(e.jwks)||!Array.isArray(e.jwks.keys)||!Array.prototype.every.call(e.jwks.keys,g))}class Nr{constructor(t,r){if(!(t instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(t.href),this._options={agent:r==null?void 0:r.agent,headers:r==null?void 0:r.headers},this._timeoutDuration=typeof(r==null?void 0:r.timeoutDuration)=="number"?r==null?void 0:r.timeoutDuration:5e3,this._cooldownDuration=typeof(r==null?void 0:r.cooldownDuration)=="number"?r==null?void 0:r.cooldownDuration:3e4,this._cacheMaxAge=typeof(r==null?void 0:r.cacheMaxAge)=="number"?r==null?void 0:r.cacheMaxAge:6e5,(r==null?void 0:r[te])!==void 0&&(this._cache=r==null?void 0:r[te],$r(r==null?void 0:r[te],this._cacheMaxAge)&&(this._jwksTimestamp=this._cache.uat,this._local=$e(this._cache.jwks)))}coolingDown(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cooldownDuration:!1}fresh(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cacheMaxAge:!1}async getKey(t,r){(!this._local||!this.fresh())&&await this.reload();try{return await this._local(t,r)}catch(n){if(n instanceof oe&&this.coolingDown()===!1)return await this.reload(),this._local(t,r);throw n}}async reload(){this._pendingFetch&&Mr()&&(this._pendingFetch=void 0);const t=new Headers(this._options.headers);_e&&!t.has("User-Agent")&&(t.set("User-Agent",_e),this._options.headers=Object.fromEntries(t.entries())),this._pendingFetch||(this._pendingFetch=Dr(this._url,this._timeoutDuration,this._options).then(r=>{this._local=$e(r),this._cache&&(this._cache.uat=Date.now(),this._cache.jwks=r),this._jwksTimestamp=Date.now(),this._pendingFetch=void 0}).catch(r=>{throw this._pendingFetch=void 0,r})),await this._pendingFetch}}function cn(e,t){const r=new Nr(e,t),n=async(a,i)=>r.getKey(a,i);return Object.defineProperties(n,{coolingDown:{get:()=>r.coolingDown(),enumerable:!0,configurable:!1},fresh:{get:()=>r.fresh(),enumerable:!0,configurable:!1},reload:{value:()=>r.reload(),enumerable:!0,configurable:!1,writable:!1},reloading:{get:()=>!!r._pendingFetch,enumerable:!0,configurable:!1},jwks:{value:()=>{var a;return(a=r._local)==null?void 0:a.jwks()},enumerable:!0,configurable:!1,writable:!1}}),n}const on=te;class dn extends xe{encode(){const t=S(JSON.stringify({alg:"none"})),r=S(JSON.stringify(this._payload));return`${t}.${r}.`}static decode(t,r){if(typeof t!="string")throw new W("Unsecured JWT must be a string");const{0:n,1:a,2:i,length:s}=t.split(".");if(s!==3||i!=="")throw new W("Invalid Unsecured JWT");let c;try{if(c=JSON.parse(T.decode(m(n))),c.alg!=="none")throw new Error}catch{throw new W("Invalid Unsecured JWT")}return{payload:Te(c,m(a),r),header:c}}}const Br=S,Re=m,un=Object.freeze(Object.defineProperty({__proto__:null,decode:Re,encode:Br},Symbol.toStringTag,{value:"Module"}));function hn(e){let t;if(typeof e=="string"){const r=e.split(".");(r.length===3||r.length===5)&&([t]=r)}else if(typeof e=="object"&&e)if("protected"in e)t=e.protected;else throw new TypeError("Token does not contain a Protected Header");try{if(typeof t!="string"||!t)throw new Error;const r=JSON.parse(T.decode(Re(t)));if(!g(r))throw new Error;return r}catch{throw new TypeError("Invalid Token or Protected Header formatting")}}function ln(e){if(typeof e!="string")throw new W("JWTs must use Compact JWS serialization, JWT must be a string");const{1:t,length:r}=e.split(".");if(r===5)throw new W("Only JWTs using Compact JWS serialization can be decoded");if(r!==3)throw new W("Invalid JWT");if(!t)throw new W("JWTs must contain a payload");let n;try{n=Re(t)}catch{throw new W("Failed to base64url decode the payload")}let a;try{a=JSON.parse(T.decode(n))}catch{throw new W("Failed to parse the decoded payload as JSON")}if(!g(a))throw new W("Invalid JWT Claims Set");return a}async function Lr(e,t){let r,n,a;switch(e){case"HS256":case"HS384":case"HS512":r=parseInt(e.slice(-3),10),n={name:"HMAC",hash:`SHA-${r}`,length:r},a=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r=parseInt(e.slice(-3),10),ue(new Uint8Array(r>>3));case"A128KW":case"A192KW":case"A256KW":r=parseInt(e.slice(1,4),10),n={name:"AES-KW",length:r},a=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":r=parseInt(e.slice(1,4),10),n={name:"AES-GCM",length:r},a=["encrypt","decrypt"];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return l.subtle.generateKey(n,(t==null?void 0:t.extractable)??!1,a)}function ye(e){const t=(e==null?void 0:e.modulusLength)??2048;if(typeof t!="number"||t<2048)throw new y("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function Gr(e,t){let r,n;switch(e){case"PS256":case"PS384":case"PS512":r={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ye(t)},n=["sign","verify"];break;case"RS256":case"RS384":case"RS512":r={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ye(t)},n=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":r={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ye(t)},n=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":r={name:"ECDSA",namedCurve:"P-256"},n=["sign","verify"];break;case"ES384":r={name:"ECDSA",namedCurve:"P-384"},n=["sign","verify"];break;case"ES512":r={name:"ECDSA",namedCurve:"P-521"},n=["sign","verify"];break;case"Ed25519":r={name:"Ed25519"},n=["sign","verify"];break;case"EdDSA":{n=["sign","verify"];const a=(t==null?void 0:t.crv)??"Ed25519";switch(a){case"Ed25519":case"Ed448":r={name:a};break;default:throw new y("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{n=["deriveKey","deriveBits"];const a=(t==null?void 0:t.crv)??"P-256";switch(a){case"P-256":case"P-384":case"P-521":{r={name:"ECDH",namedCurve:a};break}case"X25519":case"X448":r={name:a};break;default:throw new y("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return l.subtle.generateKey(r,(t==null?void 0:t.extractable)??!1,n)}async function pn(e,t){return Gr(e,t)}async function fn(e,t){return Lr(e,t)}const yn="WebCryptoAPI";export{Cr as CompactEncrypt,Wr as CompactSign,sn as EmbeddedJWK,nn as EncryptJWT,be as FlattenedEncrypt,At as FlattenedSign,Zr as GeneralEncrypt,tn as GeneralSign,rn as SignJWT,dn as UnsecuredJWT,un as base64url,Tr as calculateJwkThumbprint,an as calculateJwkThumbprintUri,fr as compactDecrypt,Ar as compactVerify,$e as createLocalJWKSet,cn as createRemoteJWKSet,yn as cryptoRuntime,ln as decodeJwt,hn as decodeProtectedHeader,Fr as errors,on as experimental_jwksCache,mr as exportJWK,qr as exportPKCS8,Yr as exportSPKI,pt as flattenedDecrypt,Et as flattenedVerify,Xr as generalDecrypt,Qr as generalVerify,pn as generateKeyPair,fn as generateSecret,pe as importJWK,kr as importPKCS8,Vr as importSPKI,zr as importX509,te as jwksCache,en as jwtDecrypt,jr as jwtVerify};
//# sourceMappingURL=index-9664230a.js.map
